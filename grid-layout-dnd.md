# Drag and drop grid layout using react-grid-layout package.

### React-grid-layout
Responsive and supports breakpoints. Breakpoint layouts can be provided by the user
or autogenerated.

### Features
* 100% React. Compatible with server-rendered apps
* Draggable and resizable widgets.
* Static widgets. Configurable packing: horizontal, vertical, or off.
* Bounds checking for dragging and resizing.
* Widgets may be added or removed without rebuilding grid.
* Layout can be serialized and restored.
* Responsive breakpoints. Separate layouts per responsive breakpoint.
* Grid Items placed using CSS Transforms
r Compatibility with <React.StrictMode>

### Behind the scenes in React-grid-layout
RGL is a wrapper component. It doesn't render the children itslef. Instead it calculates
their position and style and then uses React to render them in place.

Here's step by step guid:
1. Initialization: You provide RGL with:
	* rowHeight: The height of a single grid row in pixels (e.g. 30px)
	* cols: The number of columns for each breakdowns (e.g. {lg: 12})
	* width: The current width of the grid container (e.g. 1200px). (RGL often calculates
			this itself via the WidthProvider HOC).
	* layouts: An object defining the x,y,w,h for each item by breakpoint.
		layout object:
		i: A unique key which must match the key prop of the corresponding child <div>
		x, y: The column and row coordinates for the item's top-left corner.
		w, h: The width and height of the item in 'grid units'.

		When the layout prop is passed to the ResponsiveGridLayout, the grid knows the
		intended position for eveny single item. It can now correctly render them spaced 
		apart, making them draggable and resizable.


2. The great calculation (The Mathematics):
	This is the core of RGL. For each child item, it calculates its pixel-perfect position
	and size.
	* Column width: This is the most importanct value:
		colWidth = (totalContainerWidth - totalMarginWidth) / number-of-columns

	* Item width: itemWidth = (w * colWidth) + ((w-1) * marginX)

	* Item Height: itemHeight = (h * rowHeight) + ((h-1) * marginY)

	* Item position : 
		itemPosX = (x * colWidth) + (x * marginY)
		itemPosY = (y * rowHeight) + (y * marginY)
	
3. Rendering: RGL applies these calculated width, height, top, and left values as inline
	CSS styles (e.g., transform: translate(Xpx, Ypx);) to a <div> that it wraps around
	each of your children. This is why your KeyParameterIndex component doesn't need to 
	worry about its position - it's being absolutely positioned by its parent wrapper.

4. Drag & Drop:
	* When you drag an item, RGL is not moving the DOM element directly.
	* It's listening to mouse/touch events and calculating which grid cell (x, y) your
		cursor is over.
	* As you drag, it updates the item's x and y in its internal state.
	* This state change triggers a re-render.
	* The re-render causes the position calculation (step 2) to run again with the new x
	  and y, and the rendering the step (step 3) updates the CSS transform property, making
	  the item snap to its new grid position. This is hight performant.

5. Responsive Breakpoints:
	* When the screen size changes, RGL checks the breakpoints and cols objects.
	* It finds the current breakpoint (e.g., window width is 800px, so it uses the sm:6 column
	layout).
	* It then looks for a layout defined for the breakpoint in the layouts prop (e.g., layout.
	sm). If none exists, it attempts to creatively compact the existing lg layout to fit the
	new sm column count, which is its "magic" responsive feature.


### How to capture layout state snapshot in RGL
To get a snapshot of the staet in react-grid-layout, you use the onLayoutChange
event handler. This handler is called whenever a layout is modified, and it 
provides the updated layout as an argument. You can then save this layout state
to your component's state or an external storage system.

`
	INSIDE REACT COMPONENT
	____

	const handleLayoutChange = (newLayout) => {
		// save the new layout to state
	}

	return (
		<ResponseGridLayout
		className="layout"
		layout={layout}
		onLayoutChange={handleLayoutChange}
		// rest of the attributes
		>
			{content}
		</ResponseGridLayout>

`







